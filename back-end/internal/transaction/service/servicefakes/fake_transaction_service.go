// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"context"
	"sync"

	"github.com/fikryfahrezy/simple-bank-statement-viewer-simulation/internal/transaction/service"
	"github.com/google/uuid"
)

type FakeTransactionService struct {
	GetBalanceStub        func(context.Context, uuid.UUID) (service.BalanceResponse, error)
	getBalanceMutex       sync.RWMutex
	getBalanceArgsForCall []struct {
		arg1 context.Context
		arg2 uuid.UUID
	}
	getBalanceReturns struct {
		result1 service.BalanceResponse
		result2 error
	}
	getBalanceReturnsOnCall map[int]struct {
		result1 service.BalanceResponse
		result2 error
	}
	GetIssuesStub        func(context.Context, service.GetIssuesRequest) ([]service.IssueResponse, int64, error)
	getIssuesMutex       sync.RWMutex
	getIssuesArgsForCall []struct {
		arg1 context.Context
		arg2 service.GetIssuesRequest
	}
	getIssuesReturns struct {
		result1 []service.IssueResponse
		result2 int64
		result3 error
	}
	getIssuesReturnsOnCall map[int]struct {
		result1 []service.IssueResponse
		result2 int64
		result3 error
	}
	UploadStatementStub        func(context.Context, service.UploadRequest) (service.UploadResponse, error)
	uploadStatementMutex       sync.RWMutex
	uploadStatementArgsForCall []struct {
		arg1 context.Context
		arg2 service.UploadRequest
	}
	uploadStatementReturns struct {
		result1 service.UploadResponse
		result2 error
	}
	uploadStatementReturnsOnCall map[int]struct {
		result1 service.UploadResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTransactionService) GetBalance(arg1 context.Context, arg2 uuid.UUID) (service.BalanceResponse, error) {
	fake.getBalanceMutex.Lock()
	ret, specificReturn := fake.getBalanceReturnsOnCall[len(fake.getBalanceArgsForCall)]
	fake.getBalanceArgsForCall = append(fake.getBalanceArgsForCall, struct {
		arg1 context.Context
		arg2 uuid.UUID
	}{arg1, arg2})
	stub := fake.GetBalanceStub
	fakeReturns := fake.getBalanceReturns
	fake.recordInvocation("GetBalance", []interface{}{arg1, arg2})
	fake.getBalanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTransactionService) GetBalanceCallCount() int {
	fake.getBalanceMutex.RLock()
	defer fake.getBalanceMutex.RUnlock()
	return len(fake.getBalanceArgsForCall)
}

func (fake *FakeTransactionService) GetBalanceCalls(stub func(context.Context, uuid.UUID) (service.BalanceResponse, error)) {
	fake.getBalanceMutex.Lock()
	defer fake.getBalanceMutex.Unlock()
	fake.GetBalanceStub = stub
}

func (fake *FakeTransactionService) GetBalanceArgsForCall(i int) (context.Context, uuid.UUID) {
	fake.getBalanceMutex.RLock()
	defer fake.getBalanceMutex.RUnlock()
	argsForCall := fake.getBalanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTransactionService) GetBalanceReturns(result1 service.BalanceResponse, result2 error) {
	fake.getBalanceMutex.Lock()
	defer fake.getBalanceMutex.Unlock()
	fake.GetBalanceStub = nil
	fake.getBalanceReturns = struct {
		result1 service.BalanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTransactionService) GetBalanceReturnsOnCall(i int, result1 service.BalanceResponse, result2 error) {
	fake.getBalanceMutex.Lock()
	defer fake.getBalanceMutex.Unlock()
	fake.GetBalanceStub = nil
	if fake.getBalanceReturnsOnCall == nil {
		fake.getBalanceReturnsOnCall = make(map[int]struct {
			result1 service.BalanceResponse
			result2 error
		})
	}
	fake.getBalanceReturnsOnCall[i] = struct {
		result1 service.BalanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTransactionService) GetIssues(arg1 context.Context, arg2 service.GetIssuesRequest) ([]service.IssueResponse, int64, error) {
	fake.getIssuesMutex.Lock()
	ret, specificReturn := fake.getIssuesReturnsOnCall[len(fake.getIssuesArgsForCall)]
	fake.getIssuesArgsForCall = append(fake.getIssuesArgsForCall, struct {
		arg1 context.Context
		arg2 service.GetIssuesRequest
	}{arg1, arg2})
	stub := fake.GetIssuesStub
	fakeReturns := fake.getIssuesReturns
	fake.recordInvocation("GetIssues", []interface{}{arg1, arg2})
	fake.getIssuesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeTransactionService) GetIssuesCallCount() int {
	fake.getIssuesMutex.RLock()
	defer fake.getIssuesMutex.RUnlock()
	return len(fake.getIssuesArgsForCall)
}

func (fake *FakeTransactionService) GetIssuesCalls(stub func(context.Context, service.GetIssuesRequest) ([]service.IssueResponse, int64, error)) {
	fake.getIssuesMutex.Lock()
	defer fake.getIssuesMutex.Unlock()
	fake.GetIssuesStub = stub
}

func (fake *FakeTransactionService) GetIssuesArgsForCall(i int) (context.Context, service.GetIssuesRequest) {
	fake.getIssuesMutex.RLock()
	defer fake.getIssuesMutex.RUnlock()
	argsForCall := fake.getIssuesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTransactionService) GetIssuesReturns(result1 []service.IssueResponse, result2 int64, result3 error) {
	fake.getIssuesMutex.Lock()
	defer fake.getIssuesMutex.Unlock()
	fake.GetIssuesStub = nil
	fake.getIssuesReturns = struct {
		result1 []service.IssueResponse
		result2 int64
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTransactionService) GetIssuesReturnsOnCall(i int, result1 []service.IssueResponse, result2 int64, result3 error) {
	fake.getIssuesMutex.Lock()
	defer fake.getIssuesMutex.Unlock()
	fake.GetIssuesStub = nil
	if fake.getIssuesReturnsOnCall == nil {
		fake.getIssuesReturnsOnCall = make(map[int]struct {
			result1 []service.IssueResponse
			result2 int64
			result3 error
		})
	}
	fake.getIssuesReturnsOnCall[i] = struct {
		result1 []service.IssueResponse
		result2 int64
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTransactionService) UploadStatement(arg1 context.Context, arg2 service.UploadRequest) (service.UploadResponse, error) {
	fake.uploadStatementMutex.Lock()
	ret, specificReturn := fake.uploadStatementReturnsOnCall[len(fake.uploadStatementArgsForCall)]
	fake.uploadStatementArgsForCall = append(fake.uploadStatementArgsForCall, struct {
		arg1 context.Context
		arg2 service.UploadRequest
	}{arg1, arg2})
	stub := fake.UploadStatementStub
	fakeReturns := fake.uploadStatementReturns
	fake.recordInvocation("UploadStatement", []interface{}{arg1, arg2})
	fake.uploadStatementMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTransactionService) UploadStatementCallCount() int {
	fake.uploadStatementMutex.RLock()
	defer fake.uploadStatementMutex.RUnlock()
	return len(fake.uploadStatementArgsForCall)
}

func (fake *FakeTransactionService) UploadStatementCalls(stub func(context.Context, service.UploadRequest) (service.UploadResponse, error)) {
	fake.uploadStatementMutex.Lock()
	defer fake.uploadStatementMutex.Unlock()
	fake.UploadStatementStub = stub
}

func (fake *FakeTransactionService) UploadStatementArgsForCall(i int) (context.Context, service.UploadRequest) {
	fake.uploadStatementMutex.RLock()
	defer fake.uploadStatementMutex.RUnlock()
	argsForCall := fake.uploadStatementArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTransactionService) UploadStatementReturns(result1 service.UploadResponse, result2 error) {
	fake.uploadStatementMutex.Lock()
	defer fake.uploadStatementMutex.Unlock()
	fake.UploadStatementStub = nil
	fake.uploadStatementReturns = struct {
		result1 service.UploadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTransactionService) UploadStatementReturnsOnCall(i int, result1 service.UploadResponse, result2 error) {
	fake.uploadStatementMutex.Lock()
	defer fake.uploadStatementMutex.Unlock()
	fake.UploadStatementStub = nil
	if fake.uploadStatementReturnsOnCall == nil {
		fake.uploadStatementReturnsOnCall = make(map[int]struct {
			result1 service.UploadResponse
			result2 error
		})
	}
	fake.uploadStatementReturnsOnCall[i] = struct {
		result1 service.UploadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTransactionService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTransactionService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.TransactionService = new(FakeTransactionService)
